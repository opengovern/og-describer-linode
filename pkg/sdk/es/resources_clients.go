// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	linode "github.com/opengovern/og-describer-linode/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Account =============================

type Account struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     linode.AccountDescription `json:"description"`
	Metadata        linode.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type AccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Account       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccountHit      `json:"hits"`
}

type AccountSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AccountHits `json:"hits"`
}

type AccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountPaginator(filters []essdk.BoolFilter, limit *int64) (AccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_account", filters, limit)
	if err != nil {
		return AccountPaginator{}, err
	}

	p := AccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountPaginator) NextPage(ctx context.Context) ([]Account, error) {
	var response AccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Account
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountFilters = map[string]string{
	"address_1":          "Description.Address1",
	"address_2":          "Description.Address2",
	"balance":            "Description.Balance",
	"balance_uninvoiced": "Description.BalanceUninvoiced",
	"city":               "Description.City",
	"company":            "Description.Company",
	"country":            "Description.Country",
	"credit_card":        "Description.CreditCard",
	"email":              "Description.Email",
	"euuid":              "Description.Euuid",
	"first_name":         "Description.FirstName",
	"last_name":          "Description.LastName",
	"phone":              "Description.Phone",
	"state":              "Description.State",
	"tax_id":             "Description.TaxID",
	"zip":                "Description.Zip",
}

func ListAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountFilters = map[string]string{
	"address_1":          "Description.Address1",
	"address_2":          "Description.Address2",
	"balance":            "Description.Balance",
	"balance_uninvoiced": "Description.BalanceUninvoiced",
	"city":               "Description.City",
	"company":            "Description.Company",
	"country":            "Description.Country",
	"credit_card":        "Description.CreditCard",
	"email":              "Description.Email",
	"euuid":              "Description.Euuid",
	"first_name":         "Description.FirstName",
	"last_name":          "Description.LastName",
	"phone":              "Description.Phone",
	"state":              "Description.State",
	"tax_id":             "Description.TaxID",
	"zip":                "Description.Zip",
}

func GetAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Account =============================

// ==========================  START: Database =============================

type Database struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.DatabaseDescription `json:"description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type DatabaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Database      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DatabaseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DatabaseHit     `json:"hits"`
}

type DatabaseSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  DatabaseHits `json:"hits"`
}

type DatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (DatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_database", filters, limit)
	if err != nil {
		return DatabasePaginator{}, err
	}

	p := DatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DatabasePaginator) NextPage(ctx context.Context) ([]Database, error) {
	var response DatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Database
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDatabaseFilters = map[string]string{
	"allow_list":       "Description.AllowList",
	"cluster_size":     "Description.ClusterSize",
	"created":          "Description.Created",
	"encrypted":        "Description.Encrypted",
	"engine":           "Description.Engine",
	"hosts":            "Description.Hosts",
	"id":               "Description.ID",
	"instance_uri":     "Description.InstanceURI",
	"label":            "Description.Label",
	"region":           "Description.Region",
	"replication_type": "Description.ReplicationType",
	"ssl_connection":   "Description.SSLConnection",
	"status":           "Description.Status",
	"type":             "Description.Type",
	"updated":          "Description.Updated",
	"version":          "Description.Version",
}

func ListDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDatabase")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDatabaseFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase NewDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDatabaseFilters = map[string]string{
	"allow_list":       "Description.AllowList",
	"cluster_size":     "Description.ClusterSize",
	"created":          "Description.Created",
	"encrypted":        "Description.Encrypted",
	"engine":           "Description.Engine",
	"hosts":            "Description.Hosts",
	"id":               "Description.ID",
	"instance_uri":     "Description.InstanceURI",
	"label":            "Description.Label",
	"region":           "Description.Region",
	"replication_type": "Description.ReplicationType",
	"ssl_connection":   "Description.SSLConnection",
	"status":           "Description.Status",
	"type":             "Description.Type",
	"updated":          "Description.Updated",
	"version":          "Description.Version",
}

func GetDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDatabaseFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Database =============================

// ==========================  START: Domain =============================

type Domain struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     linode.DomainDescription `json:"description"`
	Metadata        linode.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type DomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Domain        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DomainHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DomainHit       `json:"hits"`
}

type DomainSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  DomainHits `json:"hits"`
}

type DomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDomainPaginator(filters []essdk.BoolFilter, limit *int64) (DomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_domain", filters, limit)
	if err != nil {
		return DomainPaginator{}, err
	}

	p := DomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DomainPaginator) NextPage(ctx context.Context) ([]Domain, error) {
	var response DomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Domain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDomainFilters = map[string]string{
	"axfr_ips":    "Description.AXfrIPs",
	"description": "Description.Description",
	"domain":      "Description.Domain",
	"domain_type": "Description.Type",
	"expire_sec":  "Description.ExpireSec",
	"id":          "Description.ID",
	"master_ips":  "Description.MasterIPs",
	"refresh_sec": "Description.RefreshSec",
	"retry_sec":   "Description.RetrySec",
	"soa_email":   "Description.SOAEmail",
	"status":      "Description.Status",
	"tags_src":    "Description.Tags",
	"ttl_sec":     "Description.TTLSec",
}

func ListDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDomain")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDomainFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDomainFilters = map[string]string{
	"axfr_ips":    "Description.AXfrIPs",
	"description": "Description.Description",
	"domain":      "Description.Domain",
	"domain_type": "Description.Type",
	"expire_sec":  "Description.ExpireSec",
	"id":          "Description.ID",
	"master_ips":  "Description.MasterIPs",
	"refresh_sec": "Description.RefreshSec",
	"retry_sec":   "Description.RetrySec",
	"soa_email":   "Description.SOAEmail",
	"status":      "Description.Status",
	"tags_src":    "Description.Tags",
	"ttl_sec":     "Description.TTLSec",
}

func GetDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDomainFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Domain =============================

// ==========================  START: Instance =============================

type Instance struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.InstanceDescription `json:"description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type InstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Instance      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type InstanceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []InstanceHit     `json:"hits"`
}

type InstanceSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  InstanceHits `json:"hits"`
}

type InstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInstancePaginator(filters []essdk.BoolFilter, limit *int64) (InstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_instance", filters, limit)
	if err != nil {
		return InstancePaginator{}, err
	}

	p := InstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InstancePaginator) NextPage(ctx context.Context) ([]Instance, error) {
	var response InstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Instance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInstanceFilters = map[string]string{
	"alerts":           "Description.Alerts",
	"backups":          "Description.Backups",
	"created":          "Description.Created",
	"hypervisor":       "Description.Hypervisor",
	"id":               "Description.ID",
	"image":            "Description.Image",
	"instance_type":    "Description.Type",
	"ipv4":             "Description.IPv4",
	"ipv6":             "Description.IPv6",
	"label":            "Description.Label",
	"region":           "Description.Region",
	"specs":            "Description.Specs",
	"status":           "Description.Status",
	"tags_src":         "Description.Tags",
	"updated":          "Description.Updated",
	"watchdog_enabled": "Description.WatchdogEnabled",
}

func ListInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInstance")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listInstanceFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance NewInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInstanceFilters = map[string]string{
	"alerts":           "Description.Alerts",
	"backups":          "Description.Backups",
	"created":          "Description.Created",
	"hypervisor":       "Description.Hypervisor",
	"id":               "Description.ID",
	"image":            "Description.Image",
	"instance_type":    "Description.Type",
	"ipv4":             "Description.IPv4",
	"ipv6":             "Description.IPv6",
	"label":            "Description.Label",
	"region":           "Description.Region",
	"specs":            "Description.Specs",
	"status":           "Description.Status",
	"tags_src":         "Description.Tags",
	"updated":          "Description.Updated",
	"watchdog_enabled": "Description.WatchdogEnabled",
}

func GetInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getInstanceFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Instance =============================

// ==========================  START: Firewall =============================

type Firewall struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.FirewallDescription `json:"description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type FirewallHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Firewall      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FirewallHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FirewallHit     `json:"hits"`
}

type FirewallSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  FirewallHits `json:"hits"`
}

type FirewallPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFirewallPaginator(filters []essdk.BoolFilter, limit *int64) (FirewallPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_firewall", filters, limit)
	if err != nil {
		return FirewallPaginator{}, err
	}

	p := FirewallPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FirewallPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FirewallPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FirewallPaginator) NextPage(ctx context.Context) ([]Firewall, error) {
	var response FirewallSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Firewall
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFirewallFilters = map[string]string{
	"created": "Description.Created",
	"id":      "Description.ID",
	"label":   "Description.Label",
	"rules":   "Description.Rules",
	"status":  "Description.Status",
	"tags":    "Description.Tags",
	"updated": "Description.Updated",
}

func ListFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFirewall")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFirewallFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall NewFirewallPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFirewall paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFirewallFilters = map[string]string{
	"created": "Description.Created",
	"id":      "Description.ID",
	"label":   "Description.Label",
	"rules":   "Description.Rules",
	"status":  "Description.Status",
	"tags":    "Description.Tags",
	"updated": "Description.Updated",
}

func GetFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFirewall")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFirewallFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Firewall =============================

// ==========================  START: Image =============================

type Image struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     linode.ImageDescription `json:"description"`
	Metadata        linode.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type ImageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Image         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ImageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ImageHit        `json:"hits"`
}

type ImageSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  ImageHits `json:"hits"`
}

type ImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewImagePaginator(filters []essdk.BoolFilter, limit *int64) (ImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_image", filters, limit)
	if err != nil {
		return ImagePaginator{}, err
	}

	p := ImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ImagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ImagePaginator) NextPage(ctx context.Context) ([]Image, error) {
	var response ImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Image
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listImageFilters = map[string]string{
	"created":     "Description.Created",
	"created_by":  "Description.CreatedBy",
	"deprecated":  "Description.Deprecated",
	"description": "Description.Description",
	"expiry":      "Description.Expiry",
	"id":          "Description.ID",
	"image_type":  "Description.Type",
	"is_public":   "Description.IsPublic",
	"label":       "Description.Label",
	"size":        "Description.Size",
	"vendor":      "Description.Vendor",
}

func ListImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListImage")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listImageFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage NewImagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListImage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getImageFilters = map[string]string{
	"created":     "Description.Created",
	"created_by":  "Description.CreatedBy",
	"deprecated":  "Description.Deprecated",
	"description": "Description.Description",
	"expiry":      "Description.Expiry",
	"id":          "Description.ID",
	"image_type":  "Description.Type",
	"is_public":   "Description.IsPublic",
	"label":       "Description.Label",
	"size":        "Description.Size",
	"vendor":      "Description.Vendor",
}

func GetImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getImageFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Image =============================

// ==========================  START: KubernetesCluster =============================

type KubernetesCluster struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     linode.KubernetesClusterDescription `json:"description"`
	Metadata        linode.Metadata                     `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type KubernetesClusterHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KubernetesCluster `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KubernetesClusterHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []KubernetesClusterHit `json:"hits"`
}

type KubernetesClusterSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KubernetesClusterHits `json:"hits"`
}

type KubernetesClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKubernetesClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KubernetesClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_kubernetes_cluster", filters, limit)
	if err != nil {
		return KubernetesClusterPaginator{}, err
	}

	p := KubernetesClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KubernetesClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KubernetesClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KubernetesClusterPaginator) NextPage(ctx context.Context) ([]KubernetesCluster, error) {
	var response KubernetesClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KubernetesCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKubernetesClusterFilters = map[string]string{
	"created":     "Description.Created",
	"id":          "Description.ID",
	"k8s_version": "Description.K8sVersion",
	"label":       "Description.Label",
	"region":      "Description.Region",
	"status":      "Description.Status",
	"tags_src":    "Description.Tags",
	"updated":     "Description.Updated",
}

func ListKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKubernetesCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKubernetesClusterFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewKubernetesClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKubernetesCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKubernetesClusterFilters = map[string]string{
	"created":     "Description.Created",
	"id":          "Description.ID",
	"k8s_version": "Description.K8sVersion",
	"label":       "Description.Label",
	"region":      "Description.Region",
	"status":      "Description.Status",
	"tags_src":    "Description.Tags",
	"updated":     "Description.Updated",
}

func GetKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKubernetesCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKubernetesClusterFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KubernetesCluster =============================

// ==========================  START: LongViewClient =============================

type LongViewClient struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     linode.LongViewClientDescription `json:"description"`
	Metadata        linode.Metadata                  `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type LongViewClientHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  LongViewClient `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type LongViewClientHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []LongViewClientHit `json:"hits"`
}

type LongViewClientSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  LongViewClientHits `json:"hits"`
}

type LongViewClientPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLongViewClientPaginator(filters []essdk.BoolFilter, limit *int64) (LongViewClientPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_longview_client", filters, limit)
	if err != nil {
		return LongViewClientPaginator{}, err
	}

	p := LongViewClientPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LongViewClientPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LongViewClientPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LongViewClientPaginator) NextPage(ctx context.Context) ([]LongViewClient, error) {
	var response LongViewClientSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LongViewClient
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLongViewClientFilters = map[string]string{
	"api_key":      "Description.APIKey",
	"apps":         "Description.Apps",
	"created":      "Description.Created",
	"id":           "Description.ID",
	"install_code": "Description.InstallCode",
	"label":        "Description.Label",
	"updated":      "Description.Updated",
}

func ListLongViewClient(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLongViewClient")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLongViewClientPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLongViewClientFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient NewLongViewClientPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLongViewClient paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLongViewClientFilters = map[string]string{
	"api_key":      "Description.APIKey",
	"apps":         "Description.Apps",
	"created":      "Description.Created",
	"id":           "Description.ID",
	"install_code": "Description.InstallCode",
	"label":        "Description.Label",
	"updated":      "Description.Updated",
}

func GetLongViewClient(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLongViewClient")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLongViewClientPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLongViewClientFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LongViewClient =============================

// ==========================  START: NodeBalancer =============================

type NodeBalancer struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     linode.NodeBalancerDescription `json:"description"`
	Metadata        linode.Metadata                `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type NodeBalancerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  NodeBalancer  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NodeBalancerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []NodeBalancerHit `json:"hits"`
}

type NodeBalancerSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  NodeBalancerHits `json:"hits"`
}

type NodeBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNodeBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (NodeBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_nodebalancer", filters, limit)
	if err != nil {
		return NodeBalancerPaginator{}, err
	}

	p := NodeBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NodeBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NodeBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NodeBalancerPaginator) NextPage(ctx context.Context) ([]NodeBalancer, error) {
	var response NodeBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NodeBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNodeBalancerFilters = map[string]string{
	"client_conn_throttle": "Description.ClientConnThrottle",
	"created":              "Description.Created",
	"hostname":             "Description.Hostname",
	"id":                   "Description.ID",
	"ipv4":                 "Description.IPv4",
	"ipv6":                 "Description.IPv6",
	"label":                "Description.Label",
	"region":               "Description.Region",
	"tags":                 "Description.Tags",
	"transfer":             "Description.Transfer",
	"updated":              "Description.Updated",
}

func ListNodeBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNodeBalancer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNodeBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNodeBalancerFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer NewNodeBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNodeBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNodeBalancerFilters = map[string]string{
	"client_conn_throttle": "Description.ClientConnThrottle",
	"created":              "Description.Created",
	"hostname":             "Description.Hostname",
	"id":                   "Description.ID",
	"ipv4":                 "Description.IPv4",
	"ipv6":                 "Description.IPv6",
	"label":                "Description.Label",
	"region":               "Description.Region",
	"tags":                 "Description.Tags",
	"transfer":             "Description.Transfer",
	"updated":              "Description.Updated",
}

func GetNodeBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNodeBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNodeBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNodeBalancerFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NodeBalancer =============================

// ==========================  START: ObjectStorageBucket =============================

type ObjectStorageBucket struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     linode.ObjectStorageBucketDescription `json:"description"`
	Metadata        linode.Metadata                       `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type ObjectStorageBucketHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ObjectStorageBucket `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ObjectStorageBucketHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ObjectStorageBucketHit `json:"hits"`
}

type ObjectStorageBucketSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ObjectStorageBucketHits `json:"hits"`
}

type ObjectStorageBucketPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewObjectStorageBucketPaginator(filters []essdk.BoolFilter, limit *int64) (ObjectStorageBucketPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_objectstorage", filters, limit)
	if err != nil {
		return ObjectStorageBucketPaginator{}, err
	}

	p := ObjectStorageBucketPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ObjectStorageBucketPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ObjectStorageBucketPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ObjectStorageBucketPaginator) NextPage(ctx context.Context) ([]ObjectStorageBucket, error) {
	var response ObjectStorageBucketSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ObjectStorageBucket
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listObjectStorageBucketFilters = map[string]string{
	"cluster":  "Description.Cluster",
	"created":  "Description.Created",
	"hostname": "Description.Hostname",
	"label":    "Description.Label",
	"objects":  "Description.Objects",
	"region":   "Description.Region",
	"size":     "Description.Size",
}

func ListObjectStorageBucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListObjectStorageBucket")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewObjectStorageBucketPaginator(essdk.BuildFilter(ctx, d.QueryContext, listObjectStorageBucketFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket NewObjectStorageBucketPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListObjectStorageBucket paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getObjectStorageBucketFilters = map[string]string{
	"cluster":  "Description.Cluster",
	"created":  "Description.Created",
	"hostname": "Description.Hostname",
	"label":    "Description.Label",
	"objects":  "Description.Objects",
	"region":   "Description.Region",
	"size":     "Description.Size",
}

func GetObjectStorageBucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetObjectStorageBucket")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewObjectStorageBucketPaginator(essdk.BuildFilter(ctx, d.QueryContext, getObjectStorageBucketFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ObjectStorageBucket =============================

// ==========================  START: StackScript =============================

type StackScript struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     linode.StackScriptDescription `json:"description"`
	Metadata        linode.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type StackScriptHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StackScript   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StackScriptHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StackScriptHit  `json:"hits"`
}

type StackScriptSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StackScriptHits `json:"hits"`
}

type StackScriptPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStackScriptPaginator(filters []essdk.BoolFilter, limit *int64) (StackScriptPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_stackscript", filters, limit)
	if err != nil {
		return StackScriptPaginator{}, err
	}

	p := StackScriptPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StackScriptPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StackScriptPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StackScriptPaginator) NextPage(ctx context.Context) ([]StackScript, error) {
	var response StackScriptSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StackScript
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStackScriptFilters = map[string]string{
	"created":             "Description.Created",
	"deployments_active":  "Description.DeploymentsActive",
	"deployments_total":   "Description.DeploymentsTotal",
	"description":         "Description.Description",
	"id":                  "Description.ID",
	"images":              "Description.Images",
	"is_public":           "Description.IsPublic",
	"label":               "Description.Label",
	"logo_url":            "Description.LogoURL",
	"mine":                "Description.Mine",
	"ordinal":             "Description.Ordinal",
	"rev_note":            "Description.RevNote",
	"script":              "Description.Script",
	"updated":             "Description.Updated",
	"user_defined_fields": "Description.UserDefinedFields",
	"user_gravatar_id":    "Description.UserGravatarID",
	"username":            "Description.Username",
}

func ListStackScript(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStackScript")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStackScriptPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStackScriptFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript NewStackScriptPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStackScript paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStackScriptFilters = map[string]string{
	"created":             "Description.Created",
	"deployments_active":  "Description.DeploymentsActive",
	"deployments_total":   "Description.DeploymentsTotal",
	"description":         "Description.Description",
	"id":                  "Description.ID",
	"images":              "Description.Images",
	"is_public":           "Description.IsPublic",
	"label":               "Description.Label",
	"logo_url":            "Description.LogoURL",
	"mine":                "Description.Mine",
	"ordinal":             "Description.Ordinal",
	"rev_note":            "Description.RevNote",
	"script":              "Description.Script",
	"updated":             "Description.Updated",
	"user_defined_fields": "Description.UserDefinedFields",
	"user_gravatar_id":    "Description.UserGravatarID",
	"username":            "Description.Username",
}

func GetStackScript(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStackScript")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStackScriptPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStackScriptFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StackScript =============================

// ==========================  START: Volume =============================

type Volume struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     linode.VolumeDescription `json:"description"`
	Metadata        linode.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type VolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Volume        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VolumeHit       `json:"hits"`
}

type VolumeSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  VolumeHits `json:"hits"`
}

type VolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVolumePaginator(filters []essdk.BoolFilter, limit *int64) (VolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_volume", filters, limit)
	if err != nil {
		return VolumePaginator{}, err
	}

	p := VolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VolumePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VolumePaginator) NextPage(ctx context.Context) ([]Volume, error) {
	var response VolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Volume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVolumeFilters = map[string]string{
	"created":         "Description.Created",
	"filesystem_path": "Description.FilesystemPath",
	"id":              "Description.ID",
	"label":           "Description.Label",
	"linode_id":       "Description.LinodeID",
	"region":          "Description.Region",
	"size":            "Description.Size",
	"status":          "Description.Status",
	"tags_src":        "Description.Tags",
	"updated":         "Description.Updated",
}

func ListVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVolume")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, listVolumeFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewVolumePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVolume paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVolumeFilters = map[string]string{
	"created":         "Description.Created",
	"filesystem_path": "Description.FilesystemPath",
	"id":              "Description.ID",
	"label":           "Description.Label",
	"linode_id":       "Description.LinodeID",
	"region":          "Description.Region",
	"size":            "Description.Size",
	"status":          "Description.Status",
	"tags_src":        "Description.Tags",
	"updated":         "Description.Updated",
}

func GetVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVolume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, getVolumeFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Volume =============================

// ==========================  START: VPC =============================

type VPC struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     linode.VPCDescription `json:"description"`
	Metadata        linode.Metadata       `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type VPCHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VPC           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VPCHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VPCHit          `json:"hits"`
}

type VPCSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  VPCHits `json:"hits"`
}

type VPCPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVPCPaginator(filters []essdk.BoolFilter, limit *int64) (VPCPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_vpc", filters, limit)
	if err != nil {
		return VPCPaginator{}, err
	}

	p := VPCPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VPCPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VPCPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VPCPaginator) NextPage(ctx context.Context) ([]VPC, error) {
	var response VPCSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VPC
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVPCFilters = map[string]string{
	"created":     "Description.Created",
	"description": "Description.Description",
	"id":          "Description.ID",
	"label":       "Description.Label",
	"region":      "Description.Region",
	"subnets":     "Description.Subnets",
	"updated":     "Description.Updated",
}

func ListVPC(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVPC")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVPCPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVPCFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC NewVPCPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVPC paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVPCFilters = map[string]string{
	"created":     "Description.Created",
	"description": "Description.Description",
	"id":          "Description.ID",
	"label":       "Description.Label",
	"region":      "Description.Region",
	"subnets":     "Description.Subnets",
	"updated":     "Description.Updated",
}

func GetVPC(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVPC")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVPCPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVPCFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VPC =============================

// ==========================  START: IPAddress =============================

type IPAddress struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     linode.IPAddressDescription `json:"description"`
	Metadata        linode.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type IPAddressHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IPAddress     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IPAddressHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IPAddressHit    `json:"hits"`
}

type IPAddressSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  IPAddressHits `json:"hits"`
}

type IPAddressPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIPAddressPaginator(filters []essdk.BoolFilter, limit *int64) (IPAddressPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_ipaddress", filters, limit)
	if err != nil {
		return IPAddressPaginator{}, err
	}

	p := IPAddressPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IPAddressPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IPAddressPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IPAddressPaginator) NextPage(ctx context.Context) ([]IPAddress, error) {
	var response IPAddressSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IPAddress
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIPAddressFilters = map[string]string{
	"address":     "Description.Address",
	"gateway":     "Description.Gateway",
	"linode_id":   "Description.LinodeID",
	"prefix":      "Description.Prefix",
	"public":      "Description.Public",
	"rdns":        "Description.RDNS",
	"region":      "Description.Region",
	"reserved":    "Description.Reserved",
	"subnet_mask": "Description.SubnetMask",
	"type":        "Description.Type",
	"vpc_nat_1_1": "Description.VPCNAT1To1",
}

func ListIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIPAddress")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIPAddressPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIPAddressFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress NewIPAddressPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIPAddress paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIPAddressFilters = map[string]string{
	"address":     "Description.Address",
	"gateway":     "Description.Gateway",
	"linode_id":   "Description.LinodeID",
	"prefix":      "Description.Prefix",
	"public":      "Description.Public",
	"rdns":        "Description.RDNS",
	"region":      "Description.Region",
	"reserved":    "Description.Reserved",
	"subnet_mask": "Description.SubnetMask",
	"type":        "Description.Type",
	"vpc_nat_1_1": "Description.VPCNAT1To1",
}

func GetIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIPAddress")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIPAddressPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIPAddressFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IPAddress =============================
