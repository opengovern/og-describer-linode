// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	linode "github.com/opengovern/og-describer-linode/discovery/provider"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Account =============================

type Account struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     linode.AccountDescription `json:"Description"`
	Metadata        linode.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type AccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Account       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccountHit      `json:"hits"`
}

type AccountSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AccountHits `json:"hits"`
}

type AccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountPaginator(filters []essdk.BoolFilter, limit *int64) (AccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_account", filters, limit)
	if err != nil {
		return AccountPaginator{}, err
	}

	p := AccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountPaginator) NextPage(ctx context.Context) ([]Account, error) {
	var response AccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Account
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountFilters = map[string]string{
	"account":            "Description.Account",
	"address_1":          "Description.Address1",
	"address_2":          "Description.Address2",
	"balance":            "Description.Balance",
	"balance_uninvoiced": "Description.BalanceUninvoiced",
	"city":               "Description.City",
	"company":            "Description.Company",
	"country":            "Description.Country",
	"credit_card":        "Description.CreditCard",
	"email":              "Description.Email",
	"first_name":         "Description.FirstName",
	"last_name":          "Description.LastName",
	"phone":              "Description.Phone",
	"state":              "Description.State",
	"tax_id":             "Description.TaxID",
	"zip":                "Description.Zip",
}

func ListAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountFilters = map[string]string{
	"account":            "Description.Account",
	"address_1":          "Description.Address1",
	"address_2":          "Description.Address2",
	"balance":            "Description.Balance",
	"balance_uninvoiced": "Description.BalanceUninvoiced",
	"city":               "Description.City",
	"company":            "Description.Company",
	"country":            "Description.Country",
	"credit_card":        "Description.CreditCard",
	"email":              "Description.Email",
	"first_name":         "Description.FirstName",
	"last_name":          "Description.LastName",
	"phone":              "Description.Phone",
	"state":              "Description.State",
	"tax_id":             "Description.TaxID",
	"zip":                "Description.Zip",
}

func GetAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Account =============================

// ==========================  START: Database =============================

type Database struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.DatabaseDescription `json:"Description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type DatabaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Database      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DatabaseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DatabaseHit     `json:"hits"`
}

type DatabaseSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  DatabaseHits `json:"hits"`
}

type DatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (DatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_database", filters, limit)
	if err != nil {
		return DatabasePaginator{}, err
	}

	p := DatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DatabasePaginator) NextPage(ctx context.Context) ([]Database, error) {
	var response DatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Database
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDatabaseFilters = map[string]string{
	"account":          "Description.Account",
	"allow_list":       "Description.AllowList",
	"cluster_size":     "Description.ClusterSize",
	"created":          "Description.Created",
	"encrypted":        "Description.Encrypted",
	"engine":           "Description.Engine",
	"hosts":            "Description.Hosts",
	"id":               "Description.ID",
	"instance_uri":     "Description.InstanceURI",
	"label":            "Description.Label",
	"region":           "Description.Region",
	"replication_type": "Description.ReplicationType",
	"ssl_connection":   "Description.SSLConnection",
	"status":           "Description.Status",
	"type":             "Description.Type",
	"updated":          "Description.Updated",
	"version":          "Description.Version",
}

func ListDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDatabase")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabase NewDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDatabaseFilters = map[string]string{
	"account":          "Description.Account",
	"allow_list":       "Description.AllowList",
	"cluster_size":     "Description.ClusterSize",
	"created":          "Description.Created",
	"encrypted":        "Description.Encrypted",
	"engine":           "Description.Engine",
	"hosts":            "Description.Hosts",
	"id":               "Description.ID",
	"instance_uri":     "Description.InstanceURI",
	"label":            "Description.Label",
	"region":           "Description.Region",
	"replication_type": "Description.ReplicationType",
	"ssl_connection":   "Description.SSLConnection",
	"status":           "Description.Status",
	"type":             "Description.Type",
	"updated":          "Description.Updated",
	"version":          "Description.Version",
}

func GetDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Database =============================

// ==========================  START: Domain =============================

type Domain struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     linode.DomainDescription `json:"Description"`
	Metadata        linode.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type DomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Domain        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DomainHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DomainHit       `json:"hits"`
}

type DomainSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  DomainHits `json:"hits"`
}

type DomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDomainPaginator(filters []essdk.BoolFilter, limit *int64) (DomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_domain", filters, limit)
	if err != nil {
		return DomainPaginator{}, err
	}

	p := DomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DomainPaginator) NextPage(ctx context.Context) ([]Domain, error) {
	var response DomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Domain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDomainFilters = map[string]string{
	"account":     "Description.Account",
	"axfr_ips":    "Description.AXfrIPs",
	"description": "Description.Description",
	"domain":      "Description.Domain",
	"expire_sec":  "Description.ExpireSec",
	"group":       "Description.Group",
	"id":          "Description.ID",
	"master_ips":  "Description.MasterIPs",
	"refresh_sec": "Description.RefreshSec",
	"retry_sec":   "Description.RetrySec",
	"soa_email":   "Description.SOAEmail",
	"status":      "Description.Status",
	"ttl_sec":     "Description.TTLSec",
	"type":        "Description.Type",
}

func ListDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDomain")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDomainFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDomain NewDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDomainFilters = map[string]string{
	"account":     "Description.Account",
	"axfr_ips":    "Description.AXfrIPs",
	"description": "Description.Description",
	"domain":      "Description.Domain",
	"expire_sec":  "Description.ExpireSec",
	"group":       "Description.Group",
	"id":          "Description.ID",
	"master_ips":  "Description.MasterIPs",
	"refresh_sec": "Description.RefreshSec",
	"retry_sec":   "Description.RetrySec",
	"soa_email":   "Description.SOAEmail",
	"status":      "Description.Status",
	"ttl_sec":     "Description.TTLSec",
	"type":        "Description.Type",
}

func GetDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDomainFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Domain =============================

// ==========================  START: Event =============================

type Event struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     linode.EventDescription `json:"Description"`
	Metadata        linode.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type EventHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Event         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EventHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EventHit        `json:"hits"`
}

type EventSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  EventHits `json:"hits"`
}

type EventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventPaginator(filters []essdk.BoolFilter, limit *int64) (EventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_event", filters, limit)
	if err != nil {
		return EventPaginator{}, err
	}

	p := EventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventPaginator) NextPage(ctx context.Context) ([]Event, error) {
	var response EventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Event
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventFilters = map[string]string{
	"account":          "Description.Account",
	"action":           "Description.Action",
	"created":          "Description.Created",
	"duration":         "Description.Duration",
	"entity":           "Description.Entity",
	"id":               "Description.ID",
	"message":          "Description.Message",
	"percent_complete": "Description.PercentComplete",
	"rate":             "Description.Rate",
	"read":             "Description.Read",
	"secondary_entity": "Description.SecondaryEntity",
	"seen":             "Description.Seen",
	"status":           "Description.Status",
	"time_remaining":   "Description.TimeRemaining",
	"username":         "Description.Username",
}

func ListEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEvent")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEvent NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEvent NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEvent NewEventPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEvent paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventFilters = map[string]string{
	"account":          "Description.Account",
	"action":           "Description.Action",
	"created":          "Description.Created",
	"duration":         "Description.Duration",
	"entity":           "Description.Entity",
	"id":               "Description.ID",
	"message":          "Description.Message",
	"percent_complete": "Description.PercentComplete",
	"rate":             "Description.Rate",
	"read":             "Description.Read",
	"secondary_entity": "Description.SecondaryEntity",
	"seen":             "Description.Seen",
	"status":           "Description.Status",
	"time_remaining":   "Description.TimeRemaining",
	"username":         "Description.Username",
}

func GetEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Event =============================

// ==========================  START: Instance =============================

type Instance struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.InstanceDescription `json:"Description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type InstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Instance      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type InstanceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []InstanceHit     `json:"hits"`
}

type InstanceSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  InstanceHits `json:"hits"`
}

type InstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInstancePaginator(filters []essdk.BoolFilter, limit *int64) (InstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_instance", filters, limit)
	if err != nil {
		return InstancePaginator{}, err
	}

	p := InstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InstancePaginator) NextPage(ctx context.Context) ([]Instance, error) {
	var response InstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Instance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInstanceFilters = map[string]string{
	"account":          "Description.Account",
	"alerts":           "Description.Alerts",
	"backups":          "Description.Backups",
	"capabilities":     "Description.Capabilities",
	"created":          "Description.Created",
	"disk_encryption":  "Description.DiskEncryption",
	"group":            "Description.Group",
	"has_user_data":    "Description.HasUserData",
	"host_uuid":        "Description.HostUUID",
	"hypervisor":       "Description.Hypervisor",
	"id":               "Description.ID",
	"image":            "Description.Image",
	"instance_type":    "Description.Type",
	"ipv4":             "Description.IPv4",
	"ipv6":             "Description.IPv6",
	"label":            "Description.Label",
	"lke_cluster_id":   "Description.LKEClusterID",
	"placement_group":  "Description.PlacementGroup",
	"region":           "Description.Region",
	"specs":            "Description.Specs",
	"status":           "Description.Status",
	"tags_src":         "Description.Tags",
	"type":             "Description.Type",
	"updated":          "Description.Updated",
	"watchdog_enabled": "Description.WatchdogEnabled",
}

func ListInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInstance")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listInstanceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInstance NewInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInstanceFilters = map[string]string{
	"account":          "Description.Account",
	"alerts":           "Description.Alerts",
	"backups":          "Description.Backups",
	"capabilities":     "Description.Capabilities",
	"created":          "Description.Created",
	"disk_encryption":  "Description.DiskEncryption",
	"group":            "Description.Group",
	"has_user_data":    "Description.HasUserData",
	"host_uuid":        "Description.HostUUID",
	"hypervisor":       "Description.Hypervisor",
	"id":               "Description.ID",
	"image":            "Description.Image",
	"instance_type":    "Description.Type",
	"ipv4":             "Description.IPv4",
	"ipv6":             "Description.IPv6",
	"label":            "Description.Label",
	"lke_cluster_id":   "Description.LKEClusterID",
	"placement_group":  "Description.PlacementGroup",
	"region":           "Description.Region",
	"specs":            "Description.Specs",
	"status":           "Description.Status",
	"tags_src":         "Description.Tags",
	"type":             "Description.Type",
	"updated":          "Description.Updated",
	"watchdog_enabled": "Description.WatchdogEnabled",
}

func GetInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getInstanceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Instance =============================

// ==========================  START: Firewall =============================

type Firewall struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.FirewallDescription `json:"Description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type FirewallHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Firewall      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FirewallHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FirewallHit     `json:"hits"`
}

type FirewallSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  FirewallHits `json:"hits"`
}

type FirewallPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFirewallPaginator(filters []essdk.BoolFilter, limit *int64) (FirewallPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_firewall", filters, limit)
	if err != nil {
		return FirewallPaginator{}, err
	}

	p := FirewallPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FirewallPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FirewallPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FirewallPaginator) NextPage(ctx context.Context) ([]Firewall, error) {
	var response FirewallSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Firewall
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFirewallFilters = map[string]string{
	"account": "Description.Account",
	"created": "Description.Created",
	"id":      "Description.ID",
	"label":   "Description.Label",
	"rules":   "Description.Rules",
	"status":  "Description.Status",
	"tags":    "Description.Tags",
	"updated": "Description.Updated",
}

func ListFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFirewall")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFirewallFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewall NewFirewallPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFirewall paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFirewallFilters = map[string]string{
	"account": "Description.Account",
	"created": "Description.Created",
	"id":      "Description.ID",
	"label":   "Description.Label",
	"rules":   "Description.Rules",
	"status":  "Description.Status",
	"tags":    "Description.Tags",
	"updated": "Description.Updated",
}

func GetFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFirewall")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFirewallFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Firewall =============================

// ==========================  START: Image =============================

type Image struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     linode.ImageDescription `json:"Description"`
	Metadata        linode.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type ImageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Image         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ImageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ImageHit        `json:"hits"`
}

type ImageSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  ImageHits `json:"hits"`
}

type ImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewImagePaginator(filters []essdk.BoolFilter, limit *int64) (ImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_image", filters, limit)
	if err != nil {
		return ImagePaginator{}, err
	}

	p := ImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ImagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ImagePaginator) NextPage(ctx context.Context) ([]Image, error) {
	var response ImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Image
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listImageFilters = map[string]string{
	"account":      "Description.Account",
	"capabilities": "Description.Capabilities",
	"created":      "Description.Created",
	"created_by":   "Description.CreatedBy",
	"deprecated":   "Description.Deprecated",
	"description":  "Description.Description",
	"eol":          "Description.EOL",
	"expiry":       "Description.Expiry",
	"id":           "Description.ID",
	"is_public":    "Description.IsPublic",
	"label":        "Description.Label",
	"regions":      "Description.Regions",
	"size":         "Description.Size",
	"status":       "Description.Status",
	"tags":         "Description.Tags",
	"total_size":   "Description.TotalSize",
	"type":         "Description.Type",
	"updated":      "Description.Updated",
	"vendor":       "Description.Vendor",
}

func ListImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListImage")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listImageFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListImage NewImagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListImage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getImageFilters = map[string]string{
	"account":      "Description.Account",
	"capabilities": "Description.Capabilities",
	"created":      "Description.Created",
	"created_by":   "Description.CreatedBy",
	"deprecated":   "Description.Deprecated",
	"description":  "Description.Description",
	"eol":          "Description.EOL",
	"expiry":       "Description.Expiry",
	"id":           "Description.ID",
	"is_public":    "Description.IsPublic",
	"label":        "Description.Label",
	"regions":      "Description.Regions",
	"size":         "Description.Size",
	"status":       "Description.Status",
	"tags":         "Description.Tags",
	"total_size":   "Description.TotalSize",
	"type":         "Description.Type",
	"updated":      "Description.Updated",
	"vendor":       "Description.Vendor",
}

func GetImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getImageFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Image =============================

// ==========================  START: KubernetesCluster =============================

type KubernetesCluster struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     linode.KubernetesClusterDescription `json:"Description"`
	Metadata        linode.Metadata                     `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type KubernetesClusterHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KubernetesCluster `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KubernetesClusterHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []KubernetesClusterHit `json:"hits"`
}

type KubernetesClusterSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KubernetesClusterHits `json:"hits"`
}

type KubernetesClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKubernetesClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KubernetesClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_kubernetes_cluster", filters, limit)
	if err != nil {
		return KubernetesClusterPaginator{}, err
	}

	p := KubernetesClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KubernetesClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KubernetesClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KubernetesClusterPaginator) NextPage(ctx context.Context) ([]KubernetesCluster, error) {
	var response KubernetesClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KubernetesCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKubernetesClusterFilters = map[string]string{
	"account":       "Description.Account",
	"control_plane": "Description.ControlPlane",
	"created":       "Description.Created",
	"id":            "Description.ID",
	"k8s_version":   "Description.K8sVersion",
	"label":         "Description.Label",
	"region":        "Description.Region",
	"status":        "Description.Status",
	"updated":       "Description.Updated",
}

func ListKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKubernetesCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKubernetesClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewKubernetesClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKubernetesCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKubernetesClusterFilters = map[string]string{
	"account":       "Description.Account",
	"control_plane": "Description.ControlPlane",
	"created":       "Description.Created",
	"id":            "Description.ID",
	"k8s_version":   "Description.K8sVersion",
	"label":         "Description.Label",
	"region":        "Description.Region",
	"status":        "Description.Status",
	"updated":       "Description.Updated",
}

func GetKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKubernetesCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKubernetesClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KubernetesCluster =============================

// ==========================  START: LongViewClient =============================

type LongViewClient struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     linode.LongViewClientDescription `json:"Description"`
	Metadata        linode.Metadata                  `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type LongViewClientHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  LongViewClient `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type LongViewClientHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []LongViewClientHit `json:"hits"`
}

type LongViewClientSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  LongViewClientHits `json:"hits"`
}

type LongViewClientPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLongViewClientPaginator(filters []essdk.BoolFilter, limit *int64) (LongViewClientPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_longview_client", filters, limit)
	if err != nil {
		return LongViewClientPaginator{}, err
	}

	p := LongViewClientPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LongViewClientPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LongViewClientPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LongViewClientPaginator) NextPage(ctx context.Context) ([]LongViewClient, error) {
	var response LongViewClientSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LongViewClient
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLongViewClientFilters = map[string]string{
	"account":      "Description.Account",
	"api_key":      "Description.APIKey",
	"apps":         "Description.Apps",
	"created":      "Description.Created",
	"id":           "Description.ID",
	"install_code": "Description.InstallCode",
	"label":        "Description.Label",
	"updated":      "Description.Updated",
}

func ListLongViewClient(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLongViewClient")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLongViewClientPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLongViewClientFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLongViewClient NewLongViewClientPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLongViewClient paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLongViewClientFilters = map[string]string{
	"account":      "Description.Account",
	"api_key":      "Description.APIKey",
	"apps":         "Description.Apps",
	"created":      "Description.Created",
	"id":           "Description.ID",
	"install_code": "Description.InstallCode",
	"label":        "Description.Label",
	"updated":      "Description.Updated",
}

func GetLongViewClient(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLongViewClient")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLongViewClientPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLongViewClientFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LongViewClient =============================

// ==========================  START: NodeBalancer =============================

type NodeBalancer struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     linode.NodeBalancerDescription `json:"Description"`
	Metadata        linode.Metadata                `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type NodeBalancerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  NodeBalancer  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NodeBalancerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []NodeBalancerHit `json:"hits"`
}

type NodeBalancerSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  NodeBalancerHits `json:"hits"`
}

type NodeBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNodeBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (NodeBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_nodebalancer", filters, limit)
	if err != nil {
		return NodeBalancerPaginator{}, err
	}

	p := NodeBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NodeBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NodeBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NodeBalancerPaginator) NextPage(ctx context.Context) ([]NodeBalancer, error) {
	var response NodeBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NodeBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNodeBalancerFilters = map[string]string{
	"account":              "Description.Account",
	"client_conn_throttle": "Description.ClientConnThrottle",
	"created":              "Description.Created",
	"hostname":             "Description.Hostname",
	"id":                   "Description.ID",
	"ipv4":                 "Description.IPv4",
	"ipv6":                 "Description.IPv6",
	"label":                "Description.Label",
	"region":               "Description.Region",
	"tags":                 "Description.Tags",
	"transfer":             "Description.Transfer",
	"updated":              "Description.Updated",
}

func ListNodeBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNodeBalancer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNodeBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNodeBalancerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancer NewNodeBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNodeBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNodeBalancerFilters = map[string]string{
	"account":              "Description.Account",
	"client_conn_throttle": "Description.ClientConnThrottle",
	"created":              "Description.Created",
	"hostname":             "Description.Hostname",
	"id":                   "Description.ID",
	"ipv4":                 "Description.IPv4",
	"ipv6":                 "Description.IPv6",
	"label":                "Description.Label",
	"region":               "Description.Region",
	"tags":                 "Description.Tags",
	"transfer":             "Description.Transfer",
	"updated":              "Description.Updated",
}

func GetNodeBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNodeBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNodeBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNodeBalancerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NodeBalancer =============================

// ==========================  START: ObjectStorageBucket =============================

type ObjectStorageBucket struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     linode.ObjectStorageBucketDescription `json:"Description"`
	Metadata        linode.Metadata                       `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type ObjectStorageBucketHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ObjectStorageBucket `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ObjectStorageBucketHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ObjectStorageBucketHit `json:"hits"`
}

type ObjectStorageBucketSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ObjectStorageBucketHits `json:"hits"`
}

type ObjectStorageBucketPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewObjectStorageBucketPaginator(filters []essdk.BoolFilter, limit *int64) (ObjectStorageBucketPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_objectstorage", filters, limit)
	if err != nil {
		return ObjectStorageBucketPaginator{}, err
	}

	p := ObjectStorageBucketPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ObjectStorageBucketPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ObjectStorageBucketPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ObjectStorageBucketPaginator) NextPage(ctx context.Context) ([]ObjectStorageBucket, error) {
	var response ObjectStorageBucketSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ObjectStorageBucket
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listObjectStorageBucketFilters = map[string]string{
	"account":                 "Description.Account",
	"cluster":                 "Description.Cluster",
	"created":                 "Description.Created",
	"hostname":                "Description.Hostname",
	"label":                   "Description.Label",
	"objects":                 "Description.Objects",
	"platform_integration_id": "IntegrationID",
	"region":                  "Description.Region",
	"size":                    "Description.Size",
}

func ListObjectStorageBucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListObjectStorageBucket")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewObjectStorageBucketPaginator(essdk.BuildFilter(ctx, d.QueryContext, listObjectStorageBucketFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListObjectStorageBucket NewObjectStorageBucketPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListObjectStorageBucket paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getObjectStorageBucketFilters = map[string]string{
	"account":                 "Description.Account",
	"cluster":                 "Description.Cluster",
	"created":                 "Description.Created",
	"hostname":                "Description.Hostname",
	"label":                   "Description.Label",
	"objects":                 "Description.Objects",
	"platform_integration_id": "IntegrationID",
	"region":                  "Description.Region",
	"size":                    "Description.Size",
}

func GetObjectStorageBucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetObjectStorageBucket")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewObjectStorageBucketPaginator(essdk.BuildFilter(ctx, d.QueryContext, getObjectStorageBucketFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ObjectStorageBucket =============================

// ==========================  START: StackScript =============================

type StackScript struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     linode.StackScriptDescription `json:"Description"`
	Metadata        linode.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type StackScriptHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StackScript   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StackScriptHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StackScriptHit  `json:"hits"`
}

type StackScriptSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StackScriptHits `json:"hits"`
}

type StackScriptPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStackScriptPaginator(filters []essdk.BoolFilter, limit *int64) (StackScriptPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_stackscript", filters, limit)
	if err != nil {
		return StackScriptPaginator{}, err
	}

	p := StackScriptPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StackScriptPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StackScriptPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StackScriptPaginator) NextPage(ctx context.Context) ([]StackScript, error) {
	var response StackScriptSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StackScript
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStackScriptFilters = map[string]string{
	"account":             "Description.Account",
	"created":             "Description.Created",
	"deployments_active":  "Description.DeploymentsActive",
	"deployments_total":   "Description.DeploymentsTotal",
	"description":         "Description.Description",
	"id":                  "Description.ID",
	"images":              "Description.Images",
	"is_public":           "Description.IsPublic",
	"label":               "Description.Label",
	"logo_url":            "Description.LogoURL",
	"mine":                "Description.Mine",
	"ordinal":             "Description.Ordinal",
	"rev_note":            "Description.RevNote",
	"script":              "Description.Script",
	"updated":             "Description.Updated",
	"user_defined_fields": "Description.UserDefinedFields",
	"user_gravatar_id":    "Description.UserGravatarID",
	"username":            "Description.Username",
}

func ListStackScript(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStackScript")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStackScriptPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStackScriptFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStackScript NewStackScriptPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStackScript paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStackScriptFilters = map[string]string{
	"account":             "Description.Account",
	"created":             "Description.Created",
	"deployments_active":  "Description.DeploymentsActive",
	"deployments_total":   "Description.DeploymentsTotal",
	"description":         "Description.Description",
	"id":                  "Description.ID",
	"images":              "Description.Images",
	"is_public":           "Description.IsPublic",
	"label":               "Description.Label",
	"logo_url":            "Description.LogoURL",
	"mine":                "Description.Mine",
	"ordinal":             "Description.Ordinal",
	"rev_note":            "Description.RevNote",
	"script":              "Description.Script",
	"updated":             "Description.Updated",
	"user_defined_fields": "Description.UserDefinedFields",
	"user_gravatar_id":    "Description.UserGravatarID",
	"username":            "Description.Username",
}

func GetStackScript(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStackScript")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStackScriptPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStackScriptFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StackScript =============================

// ==========================  START: Volume =============================

type Volume struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     linode.VolumeDescription `json:"Description"`
	Metadata        linode.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type VolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Volume        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VolumeHit       `json:"hits"`
}

type VolumeSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  VolumeHits `json:"hits"`
}

type VolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVolumePaginator(filters []essdk.BoolFilter, limit *int64) (VolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_volume", filters, limit)
	if err != nil {
		return VolumePaginator{}, err
	}

	p := VolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VolumePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VolumePaginator) NextPage(ctx context.Context) ([]Volume, error) {
	var response VolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Volume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVolumeFilters = map[string]string{
	"account":         "Description.Account",
	"created":         "Description.Created",
	"encryption":      "Description.Encryption",
	"filesystem_path": "Description.FilesystemPath",
	"id":              "Description.ID",
	"label":           "Description.Label",
	"linode_id":       "Description.LinodeID",
	"region":          "Description.Region",
	"size":            "Description.Size",
	"status":          "Description.Status",
	"updated":         "Description.Updated",
}

func ListVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVolume")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, listVolumeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewVolumePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVolume paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVolumeFilters = map[string]string{
	"account":         "Description.Account",
	"created":         "Description.Created",
	"encryption":      "Description.Encryption",
	"filesystem_path": "Description.FilesystemPath",
	"id":              "Description.ID",
	"label":           "Description.Label",
	"linode_id":       "Description.LinodeID",
	"region":          "Description.Region",
	"size":            "Description.Size",
	"status":          "Description.Status",
	"updated":         "Description.Updated",
}

func GetVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVolume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, getVolumeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Volume =============================

// ==========================  START: VPC =============================

type VPC struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     linode.VPCDescription `json:"Description"`
	Metadata        linode.Metadata       `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type VPCHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VPC           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VPCHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VPCHit          `json:"hits"`
}

type VPCSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  VPCHits `json:"hits"`
}

type VPCPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVPCPaginator(filters []essdk.BoolFilter, limit *int64) (VPCPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_vpc", filters, limit)
	if err != nil {
		return VPCPaginator{}, err
	}

	p := VPCPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VPCPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VPCPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VPCPaginator) NextPage(ctx context.Context) ([]VPC, error) {
	var response VPCSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VPC
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVPCFilters = map[string]string{
	"account":     "Description.Account",
	"created":     "Description.Created",
	"description": "Description.Description",
	"id":          "Description.ID",
	"label":       "Description.Label",
	"region":      "Description.Region",
	"subnets":     "Description.Subnets",
	"updated":     "Description.Updated",
}

func ListVPC(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVPC")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVPCPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVPCFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVPC NewVPCPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVPC paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVPCFilters = map[string]string{
	"account":     "Description.Account",
	"created":     "Description.Created",
	"description": "Description.Description",
	"id":          "Description.ID",
	"label":       "Description.Label",
	"region":      "Description.Region",
	"subnets":     "Description.Subnets",
	"updated":     "Description.Updated",
}

func GetVPC(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVPC")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVPCPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVPCFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VPC =============================

// ==========================  START: IPAddress =============================

type IPAddress struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     linode.IPAddressDescription `json:"Description"`
	Metadata        linode.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type IPAddressHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IPAddress     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IPAddressHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IPAddressHit    `json:"hits"`
}

type IPAddressSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  IPAddressHits `json:"hits"`
}

type IPAddressPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIPAddressPaginator(filters []essdk.BoolFilter, limit *int64) (IPAddressPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_ipaddress", filters, limit)
	if err != nil {
		return IPAddressPaginator{}, err
	}

	p := IPAddressPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IPAddressPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IPAddressPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IPAddressPaginator) NextPage(ctx context.Context) ([]IPAddress, error) {
	var response IPAddressSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IPAddress
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIPAddressFilters = map[string]string{
	"account":     "Description.Account",
	"address":     "Description.Address",
	"gateway":     "Description.Gateway",
	"linode_id":   "Description.LinodeID",
	"prefix":      "Description.Prefix",
	"public":      "Description.Public",
	"rdns":        "Description.RDNS",
	"region":      "Description.Region",
	"reserved":    "Description.Reserved",
	"subnet_mask": "Description.SubnetMask",
	"type":        "Description.Type",
	"vpc_nat_1_1": "Description.VPCNAT1To1",
}

func ListIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIPAddress")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIPAddressPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIPAddressFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIPAddress NewIPAddressPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIPAddress paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIPAddressFilters = map[string]string{
	"account":     "Description.Account",
	"address":     "Description.Address",
	"gateway":     "Description.Gateway",
	"linode_id":   "Description.LinodeID",
	"prefix":      "Description.Prefix",
	"public":      "Description.Public",
	"rdns":        "Description.RDNS",
	"region":      "Description.Region",
	"reserved":    "Description.Reserved",
	"subnet_mask": "Description.SubnetMask",
	"type":        "Description.Type",
	"vpc_nat_1_1": "Description.VPCNAT1To1",
}

func GetIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIPAddress")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIPAddressPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIPAddressFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IPAddress =============================

// ==========================  START: NodeBalancerConfig =============================

type NodeBalancerConfig struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     linode.NodeBalancerConfigDescription `json:"Description"`
	Metadata        linode.Metadata                      `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type NodeBalancerConfigHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  NodeBalancerConfig `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type NodeBalancerConfigHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []NodeBalancerConfigHit `json:"hits"`
}

type NodeBalancerConfigSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  NodeBalancerConfigHits `json:"hits"`
}

type NodeBalancerConfigPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNodeBalancerConfigPaginator(filters []essdk.BoolFilter, limit *int64) (NodeBalancerConfigPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_nodebalancer_config", filters, limit)
	if err != nil {
		return NodeBalancerConfigPaginator{}, err
	}

	p := NodeBalancerConfigPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NodeBalancerConfigPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NodeBalancerConfigPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NodeBalancerConfigPaginator) NextPage(ctx context.Context) ([]NodeBalancerConfig, error) {
	var response NodeBalancerConfigSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NodeBalancerConfig
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNodeBalancerConfigFilters = map[string]string{
	"account":         "Description.Account",
	"algorithm":       "Description.Algorithm",
	"check":           "Description.Check",
	"check_attempts":  "Description.CheckAttempts",
	"check_body":      "Description.CheckBody",
	"check_interval":  "Description.CheckInterval",
	"check_passive":   "Description.CheckPassive",
	"check_path":      "Description.CheckPath",
	"check_timeout":   "Description.CheckTimeout",
	"cipher_suite":    "Description.CipherSuite",
	"id":              "Description.ID",
	"nodebalancer_id": "Description.NodeBalancerID",
	"nodes":           "Description.Nodes",
	"nodes_status":    "Description.NodesStatus",
	"port":            "Description.Port",
	"protocol":        "Description.Protocol",
	"proxy_protocol":  "Description.ProxyProtocol",
	"ssl_cert":        "Description.SSLCert",
	"ssl_commonname":  "Description.SSLCommonName",
	"ssl_fingerprint": "Description.SSLFingerprint",
	"ssl_key":         "Description.SSLKey",
	"stickiness":      "Description.Stickiness",
}

func ListNodeBalancerConfig(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNodeBalancerConfig")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancerConfig NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancerConfig NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancerConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancerConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancerConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNodeBalancerConfigPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNodeBalancerConfigFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodeBalancerConfig NewNodeBalancerConfigPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNodeBalancerConfig paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNodeBalancerConfigFilters = map[string]string{
	"account":         "Description.Account",
	"algorithm":       "Description.Algorithm",
	"check":           "Description.Check",
	"check_attempts":  "Description.CheckAttempts",
	"check_body":      "Description.CheckBody",
	"check_interval":  "Description.CheckInterval",
	"check_passive":   "Description.CheckPassive",
	"check_path":      "Description.CheckPath",
	"check_timeout":   "Description.CheckTimeout",
	"cipher_suite":    "Description.CipherSuite",
	"id":              "Description.ID",
	"nodebalancer_id": "Description.NodeBalancerID",
	"nodes":           "Description.Nodes",
	"nodes_status":    "Description.NodesStatus",
	"port":            "Description.Port",
	"protocol":        "Description.Protocol",
	"proxy_protocol":  "Description.ProxyProtocol",
	"ssl_cert":        "Description.SSLCert",
	"ssl_commonname":  "Description.SSLCommonName",
	"ssl_fingerprint": "Description.SSLFingerprint",
	"ssl_key":         "Description.SSLKey",
	"stickiness":      "Description.Stickiness",
}

func GetNodeBalancerConfig(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNodeBalancerConfig")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNodeBalancerConfigPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNodeBalancerConfigFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NodeBalancerConfig =============================

// ==========================  START: Node =============================

type Node struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     linode.NodeDescription `json:"Description"`
	Metadata        linode.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type NodeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Node          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NodeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []NodeHit         `json:"hits"`
}

type NodeSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  NodeHits `json:"hits"`
}

type NodePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNodePaginator(filters []essdk.BoolFilter, limit *int64) (NodePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_nodebalancer_node", filters, limit)
	if err != nil {
		return NodePaginator{}, err
	}

	p := NodePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NodePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NodePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NodePaginator) NextPage(ctx context.Context) ([]Node, error) {
	var response NodeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Node
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNodeFilters = map[string]string{
	"account":         "Description.Account",
	"address":         "Description.Address",
	"config_id":       "Description.ConfigID",
	"id":              "Description.ID",
	"label":           "Description.Label",
	"mode":            "Description.Mode",
	"nodebalancer_id": "Description.NodeBalancerID",
	"status":          "Description.Status",
	"weight":          "Description.Weight",
}

func ListNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNode")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNode NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNode NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNodePaginator(essdk.BuildFilter(ctx, d.QueryContext, listNodeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNode NewNodePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNode paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNodeFilters = map[string]string{
	"account":         "Description.Account",
	"address":         "Description.Address",
	"config_id":       "Description.ConfigID",
	"id":              "Description.ID",
	"label":           "Description.Label",
	"mode":            "Description.Mode",
	"nodebalancer_id": "Description.NodeBalancerID",
	"status":          "Description.Status",
	"weight":          "Description.Weight",
}

func GetNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNode")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNodePaginator(essdk.BuildFilter(ctx, d.QueryContext, getNodeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Node =============================

// ==========================  START: NodePool =============================

type NodePool struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     linode.NodePoolDescription `json:"Description"`
	Metadata        linode.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type NodePoolHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  NodePool      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NodePoolHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []NodePoolHit     `json:"hits"`
}

type NodePoolSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  NodePoolHits `json:"hits"`
}

type NodePoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNodePoolPaginator(filters []essdk.BoolFilter, limit *int64) (NodePoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_cluster_nodepool", filters, limit)
	if err != nil {
		return NodePoolPaginator{}, err
	}

	p := NodePoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NodePoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NodePoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NodePoolPaginator) NextPage(ctx context.Context) ([]NodePool, error) {
	var response NodePoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NodePool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNodePoolFilters = map[string]string{
	"account":         "Description.Account",
	"autoscaler":      "Description.Autoscaler",
	"count":           "Description.Count",
	"disk_encryption": "Description.DiskEncryption",
	"disks":           "Description.Disks",
	"id":              "Description.ID",
	"labels":          "Description.Labels",
	"nodes":           "Description.Nodes",
	"tags":            "Description.Tags",
	"taints":          "Description.Taints",
	"type":            "Description.Type",
}

func ListNodePool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNodePool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodePool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodePool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodePool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodePool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodePool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNodePoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNodePoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNodePool NewNodePoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNodePool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNodePoolFilters = map[string]string{
	"account":         "Description.Account",
	"autoscaler":      "Description.Autoscaler",
	"count":           "Description.Count",
	"disk_encryption": "Description.DiskEncryption",
	"disks":           "Description.Disks",
	"id":              "Description.ID",
	"labels":          "Description.Labels",
	"nodes":           "Description.Nodes",
	"tags":            "Description.Tags",
	"taints":          "Description.Taints",
	"type":            "Description.Type",
}

func GetNodePool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNodePool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNodePoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNodePoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NodePool =============================

// ==========================  START: ClusterNode =============================

type ClusterNode struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     linode.ClusterNodeDescription `json:"Description"`
	Metadata        linode.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type ClusterNodeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ClusterNode   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ClusterNodeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ClusterNodeHit  `json:"hits"`
}

type ClusterNodeSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  ClusterNodeHits `json:"hits"`
}

type ClusterNodePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewClusterNodePaginator(filters []essdk.BoolFilter, limit *int64) (ClusterNodePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "linode_cluster_node", filters, limit)
	if err != nil {
		return ClusterNodePaginator{}, err
	}

	p := ClusterNodePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ClusterNodePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ClusterNodePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ClusterNodePaginator) NextPage(ctx context.Context) ([]ClusterNode, error) {
	var response ClusterNodeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ClusterNode
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listClusterNodeFilters = map[string]string{
	"account":     "Description.Account",
	"id":          "Description.ID",
	"instance_id": "Description.InstanceID",
	"status":      "Description.Status",
}

func ListClusterNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListClusterNode")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListClusterNode NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListClusterNode NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListClusterNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListClusterNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListClusterNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewClusterNodePaginator(essdk.BuildFilter(ctx, d.QueryContext, listClusterNodeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListClusterNode NewClusterNodePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListClusterNode paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getClusterNodeFilters = map[string]string{
	"account":     "Description.Account",
	"id":          "Description.ID",
	"instance_id": "Description.InstanceID",
	"status":      "Description.Status",
}

func GetClusterNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetClusterNode")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewClusterNodePaginator(essdk.BuildFilter(ctx, d.QueryContext, getClusterNodeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ClusterNode =============================
